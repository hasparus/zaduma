---
/**
 * @file Optimized Image component with placeholder
 *
 * This file started as a "fork" / "eject" of Image from `@astrojs/image`,
 * because I couldn't get its props to expose from an Image component that
 * would compose it.
 *
 * The `@ts-ignore` at the top of the original file didn't add much confidence too.
 *
 * @changes
 * - Added placeholder powered by `plaiceholder` CSS strategy.
 */

import { getImage } from "astro:assets";
// import type { ImgHTMLAttributes } from "@astrojs/image/components";
// import { warnForMissingAlt } from "@astrojs/image/components";
// import type { TransformOptions } from "@astrojs/image/dist/loaders";
// import type { OutputFormat } from "@astrojs/image/dist/loaders";
// import type { ImageMetadata } from "@astrojs/image/dist/vite-plugin-astro-image";
import { getPlaiceholder } from "plaiceholder";
import fs from "node:fs/promises";

import "./Image.css";

interface LocalImageProps
  extends Omit<TransformOptions, "src">,
    Omit<ImgHTMLAttributes, "src" | "width" | "height"> {
  src: ImageMetadata | Promise<{ default: ImageMetadata }>;
  /** Defines an alternative text description of the image. Set to an empty string (alt="") if the image is not a key part of the content (it's decoration or a tracking pixel). */
  alt: string;
}

interface RemoteImageProps
  extends TransformOptions,
    astroHTML.JSX.ImgHTMLAttributes {
  src: string;
  /** Defines an alternative text description of the image. Set to an empty string (alt="") if the image is not a key part of the content (it's decoration or a tracking pixel). */
  alt: string;
  format?: OutputFormat;
  width?: number;
  height?: number;
}

export type Props = LocalImageProps | RemoteImageProps;

const { loading = "lazy", decoding = "async", ...props } = Astro.props as Props;

let width = props.width;
let height = props.height;

let src = await props.src;
if (typeof src === "object") {
  if ("default" in src) src = src.default;
  if ("src" in src) {
    src = src.src;
  }
}

let pathToImage = src.startsWith("/") ? `../../images${props.src}` : src;
let importedImage = null;

if (src.startsWith("/")) {
  const allImages = import.meta.glob("../../images/**/*");
  importedImage = (await allImages[pathToImage]()).default;
  props.width ??= importedImage.width;
  props.height ??= importedImage.height;
  if ((importedImage.format = "jpg")) importedImage.format = "webp";
}

const isRaw = src.startsWith("raw!");
if (isRaw) src = src.slice(4);

const placeholder = await getPlaiceholder(
  await fs.readFile(new URL(pathToImage, import.meta.url)),
  { size: 10 },
);

if (!width && !height && !props.aspectRatio) {
  const { metadata } = placeholder;
  width ??= metadata.width;
  props.aspectRatio ??= metadata.width / metadata.height;
}

height ??=
  typeof props.aspectRatio === "number"
    ? parseFloat(width as unknown as string) / props.aspectRatio
    : null;

props.alt ||= "";
let attrs = { src, class: "", width: props.width, height: props.height };

if (!isRaw) {
  let attributes;
  props.src = src;
  ({ src, attributes } = await getImage({
    ...props,
    src: importedImage,
    format: "webp",
    width,
    height,
  }));
  attrs = { ...attrs, ...attributes, src };
}
---

<span zaduma-image class="zaduma-image-box block relative overflow-hidden">
  <img
    {...attrs}
    class:list={["dark:opacity-80 rounded-sm", attrs.class]}
    loading={loading}
    decoding={decoding}
  />
  {
    !isRaw && (
      <span
        style={placeholder.css}
        class="absolute inset-0 w-full h-full transform scale-150 filter blur-2xl -z-10 dark:opacity-80"
      />
    )
  }
</span>
